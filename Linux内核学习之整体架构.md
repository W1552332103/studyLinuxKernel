---
title: Linux内核学习之整体架构
tags: Linux内核，整体架构
grammar_cjkRuby: true
---
# 1. 前言
本篇文章是“Linux内核学习笔记”的第二篇，本篇中主要讲解Linux内核的主要组成部分，并针对每一部分进行整体的讲解，希望通过学习本章节内容，用户能够对Linux内核有一个宏观的整体认识。
# 2. 什么是Linux内核
Linux内核只是Linux操作系统的一部分，也是最重要的一部分。对上其通过提供系统调用为应用程序提供所需服务；对下其管系统中的各种硬件设备。其在操作系统中的具体位置如下图所示：
![enter description here][1]

# 3. Linux内核的整体架构
Linux内核根据其核心的功能可以划分为五个子系统，如下图所示：
![enter description here][2]
| 子系统 | 功能 |
| --- | --- |
| Process Scheduler | 进程调度（也称为进程管理）负责管理CPU资源，以便让各个进程可以以尽量公平的方式访问CPU |
| IPC | 进程间通信。IPC不管理任何的硬件，它主要负责Linux系统中进程之间的通信 |
| Memory Manager |负责管理Memory（内存）资源，以便让各个进程可以安全地共享机器的内存资源。另外，内存管理会提供虚拟内存的机制，该机制可以让进程使用多于系统可用Memory的内存，不用的内存会通过文件系统保存在外部非易失存储器中，需要使用的时候，再取回到内存中  |
| VFS | 虚拟文件系统。Linux内核将不同功能的外部设备，例如Disk设备（硬盘、磁盘、NAND Flash、Nor Flash等）、输入输出设备、显示设备等等，抽象为可以通过统一的文件操作接口（open、close、read、write等）来访问。这就是Linux系统“一切皆是文件”的体现（其实Linux做的并不彻底，因为CPU、内存、网络等还不是文件，如果真的需要一切皆是文件，还得看贝尔实验室正在开发的"Plan 9”的） |
| Network | 网络子系统。负责管理系统的网络设备，并实现多种多样的网络标准 |

## 3.1 进程调度
进程调度是Linux内核中最重要的子系统，它主要提供对CPU的访问控制。因为在计算机中，CPU资源是有限的，而众多的应用程序都要使用CPU资源，所以需要“进程调度子系统”对CPU进行调度管理。进程调度子系统包括4个子模块（见下图），它们的功能如下： 
![enter description here][3]

|  子系统   |  功能   |
| --- | --- |
|  Scheduling Policy   |  实现进程调度的策略，它决定哪个（或哪几个）进程将拥有CPU  |
|  Architecture-specific Schedulers   |  体系结构相关的部分，用于将对不同CPU的控制，抽象为统一的接口。这些控制主要在suspend（暂停）和resume（继续）进程时使用，牵涉到CPU的寄存器访问、汇编指令操作等   |
|  Architecture-independent Scheduler   |   体系结构无关的部分。它会和“Scheduling Policy模块”沟通，决定接下来要执行哪个进程，然后通过“Architecture-specific Schedulers模块”resume指定的进程  |
|  System Call Interface   |  系统调用接口。进程调度子系统通过系统调用接口，将需要提供给用户空间的接口开放出去，同时屏蔽掉不需要用户空间程序关心的细节   |


## 3.2 内存管理
内存管理同样是Linux内核中最重要的子系统，它主要提供对内存资源的访问控制。Linux系统会在硬件物理内存和进程所使用的内存（称作虚拟内存）之间建立一种映射关系，这种映射是以进程为单位，因而不同的进程可以使用相同的虚拟内存，而这些相同的虚拟内存，可以映射到不同的物理内存上。内存管理子系统包括3个子模块（见下图），它们的功能如下： 
![enter description here][4]
|  子系统   |  功能   |
| --- | --- |
| Architecture Specific Managers | 体系结构相关部分。提供用于访问硬件Memory的虚拟接口 |
| Architecture Independent Manager | 体系结构无关部分。提供所有的内存管理机制，包括：以进程为单位的memory mapping；虚拟内存的Swapping |
|  System Call Interface | 系统调用接口。通过该接口，向用户空间程序应用程序提供内存的分配、释放，文件的map等功能 |
## 3.3 虚拟文件系统
传统意义上的文件系统，是一种存储和组织计算机数据的方法。它用易懂、人性化的方法（文件和目录结构），抽象计算机磁盘、硬盘等设备上冰冷的数据块，从而使对它们的查找和访问变得容易。因而文件系统的实质，就是“存储和组织数据的方法”，文件系统的表现形式，就是“从某个设备中读取数据和向某个设备写入数据”。

随着计算机技术的进步，存储和组织数据的方法也是在不断进步的，从而导致有多种类型的文件系统，例如FAT、FAT32、NTFS、EXT2、EXT3等等。而为了兼容，操作系统或者内核，要以相同的表现形式，同时支持多种类型的文件系统，这就延伸出了虚拟文件系统（VFS）的概念。VFS的功能就是管理各种各样的文件系统，屏蔽它们的差异，以统一的方式，为用户程序提供访问文件的接口。

我们可以从磁盘、硬盘、NAND Flash等设备中读取或写入数据，因而最初的文件系统都是构建在这些设备之上的。这个概念也可以推广到其它的硬件设备，例如内存、显示器（LCD）、键盘、串口等等。我们对硬件设备的访问控制，也可以归纳为读取或者写入数据，因而可以用统一的文件操作接口访问。Linux内核就是这样做的，除了传统的磁盘文件系统之外，它还抽象出了设备文件系统、内存文件系统等等。这些逻辑，都是由VFS子系统实现。

VFS子系统包括6个子模块（见下图），它们的功能如下：
![enter description here][5]
|  子系统   |  功能   |
| --- | --- |
| Device Drivers | 设备驱动，用于控制所有的外部设备及控制器。由于存在大量不能相互兼容的硬件设备（特别是嵌入式产品），所以也有非常多的设备驱动。因此，Linux内核中将近一半的Source Code都是设备驱动，大多数的Linux底层工程师（特别是国内的企业）都是在编写或者维护设备驱动，而无暇估计其它内容（它们恰恰是Linux内核的精髓所在）。|
| Device Independent Interface | 该模块定义了描述硬件设备的统一方式（统一设备模型），所有的设备驱动都遵守这个定义，可以降低开发的难度。同时可以用一致的形势向上提供接口。|
| Logical Systems | 每一种文件系统，都会对应一个Logical System（逻辑文件系统），它会实现具体的文件系统逻辑。|
| System Independent Interface | 该模块负责以统一的接口（快设备和字符设备）表示硬件设备和逻辑文件系统，这样上层软件就不再关心具体的硬件形态了。|
| System Call Interface | 系统调用接口，向用户空间提供访问文件系统和硬件设备的统一的接口。| 
## 3.4 网络子系统
网络子系统在Linux内核中主要负责管理各种网络设备，并实现各种网络协议栈，最终实现通过网络连接其它系统的功能。在Linux内核中，网络子系统几乎是自成体系，它包括5个子模块（见下图），它们的功能如下： 
![enter description here][6]
|  子系统   |  功能   |
| --- | --- |
| Network Device Drivers | 网络设备的驱动，和VFS子系统中的设备驱动是一样的。|
| Device Independent Interface | 和VFS子系统中的是一样的。|
| Network Protocols | 实现各种网络传输协议，例如IP, TCP, UDP等等。|
| Protocol Independent Interface | 屏蔽不同的硬件设备和网络协议，以相同的格式提供接口（socket)。|
| System Call interface | 系统调用接口，向用户空间提供访问网络设备的统一的接口。 |

## 3.5 IPC子系统
IPC子系统功能比较单一，其提供了各种进程间通信的方法，主要的通信方式如下：
1. 半双工Unix管道
1.  FIFOs(命名管道)
1.  消息队列
1.  信号量
1.  共享内存
1.  网络Socket
# 8. Linux代码目录结构
Linux内核源代码包括三个主要部分：
1. 内核核心代码，包括第3章所描述的各个子系统和子模块，以及其它的支撑子系统，例如电源管理、Linux初始化等
2. 其它非核心代码，例如库文件（因为Linux内核是一个自包含的内核，即内核不依赖其它的任何软件，自己就可以编译通过）、固件集合、KVM（虚拟机技术）等
3. 编译脚本、配置文件、帮助文档、版权说明等辅助性文件

下图示使用ls命令看到的内核源代码的顶层目录结构，具体描述如下。 
![enter description here][7]

|  子系统   |  功能   |
| --- | --- |
|include|内核头文件，需要提供给外部模块（例如用户空间代码）使用|
|kernel|Linux内核的核心代码，包含了3.2小节所描述的进程调度子系统，以及和进程调度相关的模块|
|mm| 内存管理子系统（3.3小节）|
|fs| VFS子系统（3.4小节）|
|net|不包括网络设备驱动的网络子系统（3.5小节）|
|ipc|IPC（进程间通信）子系统|
|arch| 体系结构相关的代码，例如arm, x86等等|
|init| Linux系统启动初始化相关的代码。|
|block|提供块设备的层次。|
|sound| 音频相关的驱动及子系统，可以看作“音频子系统”。|
|drivers| 设备驱动（在Linux kernel 3.10中，设备驱动占了49.4的代码量）。|
|lib|实现需要在内核中使用的库函数，例如CRC、FIFO、list、MD5等。|
|crypto|加密、解密相关的库函数。|
|security|提供安全特性（SELinux）。|
|virt| 提供虚拟机技术（KVM等）的支持。|
|usr|用于生成initramfs的代码。|
|firmware| 保存用于驱动第三方设备的固件。|
|samples| 一些示例代码。|
|tools|一些常用工具，如性能剖析、自测试等。|
|Kconfig, Kbuild, Makefile, scripts| 用于内核编译的配置文件、脚本等。|
|COPYING |版权声明。|
|MAINTAINERS|维护者名单。|
|CREDITS |Linux主要的贡献者名单。|
|REPORTING-BUGS |Bug上报的指南。|
|Documentation, README| 帮助、说明文档。 |


  [1]: ./images/1499132949605.jpg "1499132949605"
  [2]: ./images/1499133214501.jpg "1499133214501"
  [3]: ./images/1499133767028.jpg "1499133767028"
  [4]: ./images/1499134208370.jpg "1499134208370"
  [5]: ./images/1499134491792.jpg "1499134491792"
  [6]: ./images/1499134764819.jpg "1499134764819"
  [7]: ./images/1499135364413.jpg "1499135364413"